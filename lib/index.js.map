{"version":3,"file":"index.js","sources":["../src/json-parse.ts","../src/utils/is.ts","../src/json-stringify-by-type.ts"],"sourcesContent":["/*\n    jsonParse.js\n    2012-06-20\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This file creates a jsonParse function.\n    During create you can (optionally) specify some behavioural switches\n\n        require('json-bigint')(options)\n\n            The optional options parameter holds switches that drive certain\n            aspects of the parsing process:\n            * options.strict = true will warn about duplicate-key usage in the json.\n              The default (strict = false) will silently ignore those and overwrite\n              values for keys that are in duplicate use.\n\n    The resulting function follows this signature:\n        jsonParse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = jsonParse(text, function (key, value) {\n                var a;\n                if (typeof value === 'string') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*members \"\", \"\\\"\", \"\\/\", \"\\\\\", at, b, call, charAt, f, fromCharCode,\n    hasOwnProperty, message, n, name, prototype, push, r, t, text\n*/\n\nconst jsonParse = function (options) {\n  // regexpxs extracted from\n  // (c) BSD-3-Clause\n  // https://github.com/fastify/secure-json-parse/graphs/contributors and https://github.com/hapijs/bourne/graphs/contributors\n  // Here is another issue: hasOwnProperty also will override the object property\n  const suspectProtoRx =\n    /(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])/;\n  const suspectConstructorRx =\n    /(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)/;\n\n  // This is a function that can parse a JSON text, producing a JavaScript\n  // data structure. It is a simple, recursive descent parser. It does not use\n  // eval or regular expressions, so it can be used as a model for implementing\n  // a JSON parser in other languages.\n\n  // We are defining the function inside of another function to avoid creating\n  // global variables.\n\n  // Default options one can override by passing options to the parse()\n  const _options = {\n    strict: false, // not being strict means do not generate syntax errors for \"duplicate key\"\n    storeAsString: false, // toggles whether the values should be stored as BigNumber (default) or a string\n    alwaysParseAsBig: false, // toggles whether all numbers should be Big\n    useNativeBigInt: false, // toggles whether to use native BigInt instead of bignumber.js\n    protoAction: \"error\",\n    constructorAction: \"error\",\n  };\n\n  // If there are options, then use them to override the default _options\n  if (options !== undefined && options !== null) {\n    if (options.strict === true) {\n      _options.strict = true;\n    }\n    if (options.storeAsString === true) {\n      _options.storeAsString = true;\n    }\n    _options.alwaysParseAsBig =\n      options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;\n    _options.useNativeBigInt =\n      options.useNativeBigInt === true ? options.useNativeBigInt : false;\n\n    if (typeof options.constructorAction !== \"undefined\") {\n      if (\n        options.constructorAction === \"error\" ||\n        options.constructorAction === \"ignore\" ||\n        options.constructorAction === \"preserve\"\n      ) {\n        _options.constructorAction = options.constructorAction;\n      } else {\n        throw new Error(\n          `Incorrect value for constructorAction option, must be \"error\", \"ignore\" or undefined but passed ${options.constructorAction}`\n        );\n      }\n    }\n\n    if (typeof options.protoAction !== \"undefined\") {\n      if (\n        options.protoAction === \"error\" ||\n        options.protoAction === \"ignore\" ||\n        options.protoAction === \"preserve\"\n      ) {\n        _options.protoAction = options.protoAction;\n      } else {\n        throw new Error(\n          `Incorrect value for protoAction option, must be \"error\", \"ignore\" or undefined but passed ${options.protoAction}`\n        );\n      }\n    }\n  }\n\n  let at; // The index of the current character\n  let ch; // The current character\n  const escapee = {\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: \"\\n\",\n    r: \"\\r\",\n    t: \"\\t\",\n  };\n  let text;\n\n  const error = function (m) {\n    // Call error when something is wrong.\n\n    throw {\n      name: \"SyntaxError\",\n      message: m,\n      at: at,\n      text: text,\n    };\n  };\n\n  const next = function (c) {\n    // If a c parameter is provided, verify that it matches the current character.\n\n    if (c && c !== ch) {\n      error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n    }\n\n    // Get the next character. When there are no more characters,\n    // return the empty string.\n\n    ch = text.charAt(at);\n    at += 1;\n    return ch;\n  };\n\n  const number = function () {\n    // Parse a number value.\n\n    let number;\n    let string = \"\";\n\n    if (ch === \"-\") {\n      string = \"-\";\n      next(\"-\");\n    }\n    while (ch >= \"0\" && ch <= \"9\") {\n      string += ch;\n      next();\n    }\n    if (ch === \".\") {\n      string += \".\";\n      while (next() && ch >= \"0\" && ch <= \"9\") {\n        string += ch;\n      }\n    }\n    if (ch === \"e\" || ch === \"E\") {\n      string += ch;\n      next();\n      if (ch === \"-\" || ch === \"+\") {\n        string += ch;\n        next();\n      }\n      while (ch >= \"0\" && ch <= \"9\") {\n        string += ch;\n        next();\n      }\n    }\n    number = +string;\n    if (!isFinite(number)) {\n      error(\"Bad number\");\n    } else {\n      if (_options.storeAsString) {\n        return { type: \"string\", originType: \"number\", value: string };\n      }\n\n      if (Number.isSafeInteger(number))\n        if (_options.alwaysParseAsBig) {\n          return {\n            type: \"number\",\n            originType: \"number\",\n            value: BigInt(number),\n          };\n        } else {\n          return { type: \"number\", originType: \"number\", value: number };\n        }\n      // Number with fractional part should be treated as number(double) including big integers in scientific notation, i.e 1.79e+308\n      else {\n        let result;\n        if (/[\\.eE]/.test(string)) {\n          result = number;\n        } else {\n          result = BigInt(string);\n        }\n        return { type: \"number\", originType: \"number\", value: result };\n      }\n    }\n  };\n\n  const string = function () {\n    // Parse a string value.\n\n    let hex;\n    let i;\n    let string = \"\";\n    let uffff;\n\n    // When parsing for string values, we must look for \" and \\ characters.\n\n    if (ch === '\"') {\n      let startAt = at;\n      while (next()) {\n        if (ch === '\"') {\n          if (at - 1 > startAt) string += text.substring(startAt, at - 1);\n          next();\n          return { type: \"string\", originType: \"string\", value: string };\n        }\n        if (ch === \"\\\\\") {\n          if (at - 1 > startAt) string += text.substring(startAt, at - 1);\n          next();\n          if (ch === \"u\") {\n            uffff = 0;\n            for (i = 0; i < 4; i += 1) {\n              hex = parseInt(next(), 16);\n              if (!isFinite(hex)) {\n                break;\n              }\n              uffff = uffff * 16 + hex;\n            }\n            string += String.fromCharCode(uffff);\n          } else if (typeof escapee[ch] === \"string\") {\n            string += escapee[ch];\n          } else {\n            break;\n          }\n          startAt = at;\n        }\n      }\n    }\n    error(\"Bad string\");\n  };\n\n  const white = function () {\n    // Skip whitespace.\n\n    while (ch && ch <= \" \") {\n      next();\n    }\n  };\n\n  const word = function () {\n    // true, false, or null.\n\n    switch (ch) {\n      case \"t\":\n        next(\"t\");\n        next(\"r\");\n        next(\"u\");\n        next(\"e\");\n        return { type: \"boolean\", originType: \"boolean\", value: true };\n\n      case \"f\":\n        next(\"f\");\n        next(\"a\");\n        next(\"l\");\n        next(\"s\");\n        next(\"e\");\n        return { type: \"boolean\", originType: \"boolean\", value: false };\n\n      case \"n\":\n        next(\"n\");\n        next(\"u\");\n        next(\"l\");\n        next(\"l\");\n        return { type: \"null\", originType: \"null\", value: null };\n    }\n    error(\"Unexpected '\" + ch + \"'\");\n  };\n\n  let value; // Place holder for the value function.\n\n  const array = function () {\n    // Parse an array value.\n\n    const array = { type: \"array\", originType: \"array\", value: [] };\n\n    if (ch === \"[\") {\n      next(\"[\");\n      white();\n      if (ch === \"]\") {\n        next(\"]\");\n        return array; // empty array\n      }\n      while (ch) {\n        array.value.push(value());\n        white();\n        if (ch === \"]\") {\n          next(\"]\");\n          return array;\n        }\n        next(\",\");\n        white();\n      }\n    }\n    error(\"Bad array\");\n  };\n\n  const object = function () {\n    // Parse an object value.\n\n    let key;\n    const object = { type: \"object\", originType: \"object\", value: {} };\n\n    if (ch === \"{\") {\n      next(\"{\");\n      white();\n      if (ch === \"}\") {\n        next(\"}\");\n        return object; // empty object\n      }\n      while (ch) {\n        key = string()?.value;\n        white();\n        next(\":\");\n        if (\n          _options.strict === true &&\n          Object.hasOwnProperty.call(object.value, key)\n        ) {\n          error('Duplicate key \"' + key + '\"');\n        }\n\n        if (suspectProtoRx.test(key) === true) {\n          if (_options.protoAction === \"error\") {\n            error(\"Object contains forbidden prototype property\");\n          } else if (_options.protoAction === \"ignore\") {\n            value();\n          } else {\n            object.value[key] = value();\n          }\n        } else if (suspectConstructorRx.test(key) === true) {\n          if (_options.constructorAction === \"error\") {\n            error(\"Object contains forbidden constructor property\");\n          } else if (_options.constructorAction === \"ignore\") {\n            value();\n          } else {\n            object.value[key] = value();\n          }\n        } else {\n          object.value[key] = value();\n        }\n\n        white();\n        if (ch === \"}\") {\n          next(\"}\");\n          return object;\n        }\n        next(\",\");\n        white();\n      }\n    }\n    error(\"Bad object\");\n  };\n\n  value = function () {\n    // Parse a JSON value. It could be an object, an array, a string, a number,\n    // or a word.\n\n    white(); // skip initial space\n    switch (ch) {\n      case \"{\":\n        return object();\n      case \"[\":\n        return array();\n      case '\"':\n        return string();\n      case \"-\":\n        return number();\n      default:\n        return ch >= \"0\" && ch <= \"9\" ? number() : word();\n    }\n  };\n\n  // Return the jsonParse function. It will have access to all of the above\n  // functions and variables.\n\n  return function (source) {\n    text = source + \"\";\n    at = 0;\n    ch = \" \";\n    const result = value();\n    white();\n    if (ch) {\n      error(\"Syntax error\");\n    }\n\n    return result;\n  };\n};\n\nexport default jsonParse;\n","export function isArray(obj: unknown): obj is unknown[] {\n  return Object.prototype.toString.call(obj) === \"[object Array]\";\n}\n\nexport function isObject(obj: unknown): obj is { [key: string]: unknown } {\n  return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\n\nexport function isString(obj: unknown): obj is string {\n  return Object.prototype.toString.call(obj) === \"[object String]\";\n}\n\nexport function isNumber(obj: unknown): obj is number {\n  return (\n    Object.prototype.toString.call(obj) === \"[object Number]\" && obj === obj\n  );\n}\n\nexport function isBoolean(obj: unknown): obj is boolean {\n  return Object.prototype.toString.call(obj) === \"[object Boolean]\";\n}\n\nexport function isRegExp(obj: unknown) {\n  return Object.prototype.toString.call(obj) === \"[object RegExp]\";\n}\n\nexport function isFile(obj: unknown): obj is File {\n  return Object.prototype.toString.call(obj) === \"[object File]\";\n}\n\nexport function isBlob(obj: unknown): obj is Blob {\n  return Object.prototype.toString.call(obj) === \"[object Blob]\";\n}\n\nexport function isUndefined(obj: unknown): obj is undefined {\n  return obj === undefined;\n}\n\nexport function isNull(obj: unknown): obj is null {\n  return obj === null;\n}\n\nexport function isNullOrUndefined(obj: unknown): boolean {\n  return obj === null || obj === undefined;\n}\n\nexport function isFunction(\n  obj: unknown\n): obj is (...args: unknown[]) => unknown {\n  return typeof obj === \"function\";\n}\n","import { isObject, isUndefined } from \"./utils/is\";\n\ninterface IObj {\n  type: \"string\" | \"boolean\" | \"number\" | \"null\" | \"object\" | \"array\";\n  value: Array<IObj> | IObj;\n}\n\nexport default function jsonStringifyByType(obj: IObj, indentLevel = 0) {\n  if (!isObject(obj) || isUndefined(obj.type) || isUndefined(obj.value)) {\n    throw new Error(\n      `obj: ${obj} should be an object with type and originType, value`\n    );\n  }\n\n  const indentSymbol = \" \";\n  if (obj.type === \"string\") {\n    if (obj.originType === \"number\") {\n      return obj.value;\n    } else {\n      return `\"${obj.value}\"`;\n    }\n  }\n\n  if ([\"null\", \"number\", \"boolean\"].includes(obj.type)) {\n    return `${obj.value}`;\n  }\n\n  const currentIndentChars = indentSymbol.repeat(indentLevel * 2);\n  const nextIndentChars = indentSymbol.repeat((indentLevel + 1) * 2);\n  let result = obj.type === \"array\" ? `[\\n` : `{\\n`;\n\n  if (obj.type === \"array\" && Array.isArray(obj.value)) {\n    for (const [index, item] of obj.value.entries()) {\n      const value = jsonStringifyByType(item, indentLevel + 1);\n      result += `${nextIndentChars}${value}`;\n      if (index !== obj.value.length - 1) {\n        result += \",\\n\";\n      } else {\n        result += \"\\n\";\n      }\n    }\n    result += `${currentIndentChars}]`;\n  }\n\n  if (obj.type === \"object\") {\n    const keys = Object.keys(obj.value);\n    for (const [index, key] of keys.entries()) {\n      const value = jsonStringifyByType(obj.value[key], indentLevel + 1);\n      result += `${nextIndentChars}\"${key}\": ${value}`;\n      if (index !== keys.length - 1) {\n        result += \",\\n\";\n      } else {\n        result += \"\\n\";\n      }\n    }\n    result += `${currentIndentChars}}`;\n  }\n\n  return result;\n}\n"],"names":[],"mappings":"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"}